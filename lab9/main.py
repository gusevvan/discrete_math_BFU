import math


def dfs(v, G, used, matching):
    if used[v]:
        return False
    used[v] = True
    for to in G[v]:
        if matching[to] == -1 or dfs(v, G, used, matching[to]):
            matching[to] = v
            return True


def khun(G_matrix, mapper):
    N = len(G_matrix)
    G = [[] for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if G_matrix[i][j] != 0:
                G[i].append(j)
                G[j].append(i)
    matching = [-1] * N
    par = []
    for i in range(N):
        used = [False] * N
        dfs(i, G, used, matching)
        if matching[i] != -1:
            if G_matrix[matching[i]][i] != 0:
                par.append((mapper[matching[i]] + 1, mapper[i] + 1))
            else:
                par.append((mapper[i] + 1, mapper[matching[i]] + 1))
    print('Размер максимального паросочетания:', len(par))
    print('Входящие ребра:')
    for i in range(len(par)):
        print(par[i][0], par[i][1])


def get_max_vertex(k, V, S):
    m = 0   # наименьшее допустимое значение
    v = -1
    for i, w in enumerate(V[k]):
        if i in S:
            continue

        if w[2] == 1:   # движение по стрелке
            if m < w[0]:
                m = w[0]
                v = i
        else:           # движение против стрелки
            if m < w[1]:
                m = w[1]
                v = i

    return v


def get_max_flow(T):
    w = [x[0] for x in T]
    return min(*w)


def updateV(V, T, f):
    for t in T:
        if t[1] == -1:  # это исток
            continue

        sgn = V[t[2]][t[1]][2]  # направление движения

        # меняем веса в таблице для (i,j) и (j,i)
        V[t[1]][t[2]][0] -= f * sgn
        V[t[1]][t[2]][1] += f * sgn

        V[t[2]][t[1]][0] -= f * sgn
        V[t[2]][t[1]][1] += f * sgn


def fordFulkerson(V, mapper):
    N = len(V)  # число вершин в графе
    init = 0    # вершина истока (нумерация с нуля)
    end = N - 1     # вершинстока
    Tinit = (math.inf, -1, init)      # первая метка маршруто (a, from, vertex)
    f = []      # максимальные потоки найденных маршрутов
    pathes = []
    j = init
    last_S = []
    while j != -1:
        k = init  # стартовая вершина (нумерация с нуля)
        T = [Tinit]  # метки маршрута
        S = {init}  # множество просмотренных вершин

        while k != end:     # пока не дошли до стока
            j = get_max_vertex(k, V, S)  # выбираем вершину с наибольшей пропускной способностью
            if j == -1:         # если следующих вершин нет
                if k == init:      # и мы на истоке, то
                    break          # завершаем поиск маршрутов
                else:           # иначе, переходим к предыдущей вершине
                    k = T.pop()[2]
                    continue

            c = V[k][j][0] if V[k][j][2] == 1 else V[k][j][1]   # определяем текущий поток
            T.append((c, j, k))    # добавляем метку маршрута
            S.add(j)            # запоминаем вершину как просмотренную

            if j == end:    # если дошди до стока
                f.append(get_max_flow(T))     # находим максимальную пропускную способность маршрута
                updateV(V, T, f[-1])        # обновляем веса дуг
                break

            k = j
        last_S = S
        pathes.append(T)
    pathes.pop()
    F = sum(f)
    print(f"Размер максимального паросочетания: {F}")
    print('Входящие ребра:')
    for i, path in enumerate(pathes):
        x = []
        prev = False
        for j in range(1, len(path[1:]) + 1):
            if V[path[j][1]][path[j][2]][2] != -1:
                prev = True
            else:
                if not prev:
                    x.append(mapper[path[j][2]])
                prev = False
        print(x[1], x[2])


def check_bipartite(G):
    N = len(G)
    max_iter = 2**N
    min_to_del = float('inf')
    to_del, L, R = [], [], []
    for i in range(max_iter):
        cur_bin = bin(i)[2:].zfill(N)
        cur_count = 0
        cur_to_del = []
        for j in range(N):
            for k in range(N):
                if cur_bin[j] == cur_bin[k] and G[j][k] != 0:
                    cur_count += 1
                    cur_to_del.append((j, k))
        if cur_count < min_to_del:
            min_to_del = cur_count
            to_del = cur_to_del
            cur_L, cur_R = [], []
            for j in range(N):
                if cur_bin[j] == '0':
                    cur_L.append(j)
                else:
                    cur_R.append(j)
            L = cur_L
            R = cur_R
    return min_to_del, to_del, L, R


def main():
    G_matrix = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0],
                [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
                [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
    min_to_del, to_del, L, R = check_bipartite(G_matrix)
    print('Граф двудольный.')
    L = list(map(lambda x: x + 2, L))
    R = list(map(lambda x: x + 2, R))
    print('Доли:')
    print(L)
    print(R)
    V = [[[0,0,1],[0,0,1],[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
         [[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[1,0,1],[0,0,1]],
         [[1,0,-1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
         [[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[1,0,1]],
         [[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[1,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1]],
         [[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
         [[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
         [[0,0,1],[1,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[1,0,-1],[0,0,1],[1,0,-1],[1,0,-1],[1,0,-1],[1,0,-1],[1,0,-1],[1,0,-1],[0,0,1],[1,0,-1],[0,0,1]]
         ]
    mapper = dict(zip(range(17), range(1, 18)))
    print('Используем алгоритм Форда-Фалкерсона:')
    fordFulkerson(V, mapper)
    print('Используем алгоритм Куна:')
    khun(G_matrix, mapper)


main()
